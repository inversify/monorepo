---
sidebar_position: 1
title: Controller
---

import controllerApiBasicsSource from '@inversifyjs/http-code-examples/generated/examples/v0/controllerApiBasics.ts.txt';
import controllerApiInheritanceSource from '@inversifyjs/http-code-examples/generated/examples/v0/controllerApiInheritance.ts.txt';
import controllerApiRegisterSource from '@inversifyjs/http-code-examples/generated/examples/v0/controllerApiRegister.ts.txt';
import controllerNonNativeTypesSource from '@inversifyjs/http-code-examples/generated/examples/v0/controllerNonNativeTypes.ts.txt';
import decoratorApiResponseExpress4Source from '@inversifyjs/http-code-examples/generated/examples/v0/decoratorApiResponseExpress4.ts.txt';
import decoratorApiResponseExpressSource from '@inversifyjs/http-code-examples/generated/examples/v0/decoratorApiResponseExpress.ts.txt';
import decoratorApiResponseFastifySource from '@inversifyjs/http-code-examples/generated/examples/v0/decoratorApiResponseFastify.ts.txt';
import decoratorApiResponseHonoSource from '@inversifyjs/http-code-examples/generated/examples/v0/decoratorApiResponseHono.ts.txt';
import decoratorApiResponseUwebsocketsSource from '@inversifyjs/http-code-examples/generated/examples/v0/decoratorApiResponseUwebsockets.ts.txt';
import CodeBlock from '@theme/CodeBlock';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Controller

Controllers are classes annotated with the `@Controller()` decorator. They group request handlers for a feature area. A controller defines a base path and one or more route handlers using [method decorators](../../api/decorators/#http-methods).

:::info[Controller and injectable decorators]
You don't need to add `@injectable()`. The `@Controller()` decorator already applies it for you.
:::

## Basic example

A minimal controller with one route:

<CodeBlock language="ts">{controllerApiBasicsSource}</CodeBlock>

## Registering a controller

Register controllers in your container. Bind your controller class and choose a scope.

<CodeBlock language="ts">{controllerApiRegisterSource}</CodeBlock>

When you call `build()` on your server adapter, it builds routes from controller metadata at runtime.

:::tip[Controller registration order]
Controllers are registered in descending order of priority (highest first). Use the `priority` option in `@Controller()` to control route evaluation order. This is useful for ensuring specific routes are matched before more general ones, or for implementing custom fallback handlers like a 404 route. See the [Controller decorator API](../../api/decorators/#controller) for details.
:::

## Implementation approaches

There are two complementary ways to write controller routes in Inversify HTTP. You can keep your handlers framework-agnostic and let Inversify send the response for you, or you can opt into native adapter types and take full control of the underlying framework's response flow.

### 1. Non-native types (Recommended)

With the framework-agnostic approach, your controller methods return values and Inversify converts them into HTTP responses. The adapter decides how to shape the response based on the value: strings are sent as plain text, objects (including undefined) are sent as JSON, Node streams are piped as streaming responses, and primitive values like numbers or booleans are stringified as text. The status code is 200 by default, but you can override it per route with the `@StatusCode()` decorator or by returning a typed `HttpResponse` (for example, `new CreatedHttpResponse(body)` or throwing an `ErrorHttpResponse`). This keeps controllers portable across adapters and focuses them on business logic rather than framework details.

<CodeBlock language="ts">{controllerNonNativeTypesSource}</CodeBlock>

### 2. Native types (Advanced)

If you need direct access to adapter features, inject native types with `@Response()` and `@Next()`. In this mode you're responsible for the full response lifecycle: setting headers, choosing the status code, sending the body (or streaming), and deciding whether to call `next()` to continue the pipeline. This trades portability for full control and is useful for advanced scenarios like fine-grained caching headers, streaming, or integrating with middleware that expects native objects.

Usage with different adapters:

<Tabs>
  <TabItem value="express4" label="Express 4">
    <CodeBlock language="ts">{decoratorApiResponseExpress4Source}</CodeBlock>
  </TabItem>
  <TabItem value="express5" label="Express 5">
    <CodeBlock language="ts">{decoratorApiResponseExpressSource}</CodeBlock>
  </TabItem>
  <TabItem value="fastify" label="Fastify">
    <CodeBlock language="ts">{decoratorApiResponseFastifySource}</CodeBlock>
  </TabItem>
  <TabItem value="hono" label="Hono">
    <CodeBlock language="ts">{decoratorApiResponseHonoSource}</CodeBlock>
  </TabItem>
  <TabItem value="uwebsockets" label="uWebSockets.js">
    <CodeBlock language="ts">{decoratorApiResponseUwebsocketsSource}</CodeBlock>
  </TabItem>
</Tabs>

:::tip[When to use native types]
Reach for native types when you need precise control over the HTTP exchangeâ€”streaming large payloads, fine-tuning caching and headers, squeezing out adapter-specific performance, or interoperating with middleware that expects a native response object. For most routes, the framework-agnostic approach remains simpler, more portable, and easier to test.
:::

:::warning[Important: Choose one approach per route]
Avoid mixing modes within the same route. If you inject `@Response()` or `@Next()`, your handler should manage the response entirely and typically return `void` (or the framework `Response` for Hono). Conversely, when you return values for Inversify to send, don't also write to the native response object.
:::

## Inheritance

Controllers support inheritance, allowing you to define base controllers with common route handlers that can be reused and optionally overridden in derived controllers. This promotes code reuse and consistency across similar endpoints.

<CodeBlock language="ts">{controllerApiInheritanceSource}</CodeBlock>

### How inheritance works

When a controller extends a base class:

- **All route handlers from the base controller are inherited** - The derived controller automatically includes all HTTP method decorators (`@Get()`, `@Post()`, etc.) from its parent classes
- **Routes can be overridden** - If a derived controller defines a route with the same HTTP method and path as its base class, the derived implementation takes precedence
- **Base path applies to all routes** - The `@Controller()` path specified on the derived class applies to both inherited and overridden routes
- **Metadata walks up the prototype chain** - The framework traverses the entire inheritance hierarchy to collect all route metadata

:::info[Route collision resolution]
When a derived controller defines a route with the same HTTP method and path as its parent, the derived controller's implementation takes precedence. This allows you to selectively customize behavior while keeping the base implementation for other routes.
:::
